---
import {
    blogIndex as blogIndexPromise,
    type HierarchicalBlogNode,
} from "../blogIndex";
import Graph from "../components/Graph.astro";
import Layout from "../layouts/Base.astro";

interface ClientGraphNode {
    id: string;
    isFolder: boolean;
    initialDepth: number;
}

interface ClientGraphLink {
    source: string;
    target: string;
    isBacklink: boolean;
}

const SYNTHETIC_ROOT_ID = "/";

const allNodesMap: Map<string, HierarchicalBlogNode> = await blogIndexPromise;

const clientNodes: ClientGraphNode[] = [];
const clientLinks: ClientGraphLink[] = [];
const visitedDepths = new Map<string, number>();

clientNodes.push({
    id: SYNTHETIC_ROOT_ID,
    isFolder: true,
    initialDepth: 0,
});
visitedDepths.set(SYNTHETIC_ROOT_ID, 0);

const queue: { nodeId: string; depth: number }[] = [];
for (const node of allNodesMap.values()) {
    if (!node.parent) {
        const actualNodeIdWithSlash = "/" + node.id;
        clientLinks.push({
            source: SYNTHETIC_ROOT_ID,
            target: actualNodeIdWithSlash,
            isBacklink: false,
        });
        if (!visitedDepths.has(actualNodeIdWithSlash)) {
            queue.push({ nodeId: node.id, depth: 1 });
            visitedDepths.set(actualNodeIdWithSlash, 1);
        }
    }
}

let head = 0;
while (head < queue.length) {
    const { nodeId, depth } = queue[head++];
    const blogNode = allNodesMap.get(nodeId);
    if (!blogNode) continue;
    if (blogNode.children.length > 0) {
        for (const childId of blogNode.children) {
            const actualChildIdWithSlash = "/" + childId;
            if (!visitedDepths.has(actualChildIdWithSlash)) {
                visitedDepths.set(actualChildIdWithSlash, depth + 1);
                queue.push({ nodeId: childId, depth: depth + 1 });
            }
        }
    }
}

function getEffectiveGraphId(originalId: string): string {
    const hNode = allNodesMap.get(originalId);
    if (hNode && hNode.isFolderNote && !hNode.isFolder && hNode.parent) {
        return "/" + hNode.parent;
    }
    return "/" + originalId;
}

const linkSet = new Set<string>();
clientLinks.forEach((link) => {
    if (link.source === SYNTHETIC_ROOT_ID) {
        linkSet.add([link.source, link.target].sort().join("--"));
    }
});

for (const node of allNodesMap.values()) {
    if (!node.isFolder && node.data?.draft) {
        continue;
    }

    if (node.isFolderNote && !node.isFolder) {
        continue;
    }

    const actualNodeIdWithSlash = "/" + node.id;
    const depth = visitedDepths.get(actualNodeIdWithSlash);

    if (depth === undefined) {
        console.warn(
            `Node ${actualNodeIdWithSlash} (original ID: ${node.id}) has undefined depth and will be skipped for the graph.`,
        );
        continue;
    }

    if (!clientNodes.find((cn) => cn.id === actualNodeIdWithSlash)) {
        clientNodes.push({
            id: actualNodeIdWithSlash,
            isFolder: node.isFolder,
            initialDepth: depth,
        });
    }

    if (node.children.length > 0) {
        for (const childId of node.children) {
            const childHNode = allNodesMap.get(childId);
            if (
                childHNode &&
                !(!childHNode.isFolder && childHNode.data?.draft)
            ) {
                // Not a draft file
                const sourceGraphId = getEffectiveGraphId(node.id);
                const targetGraphId = getEffectiveGraphId(childId);

                const linkKey = [sourceGraphId, targetGraphId]
                    .sort()
                    .join("--");
                if (!linkSet.has(linkKey)) {
                    clientLinks.push({
                        source: sourceGraphId,
                        target: targetGraphId,
                        isBacklink: false,
                    });
                    linkSet.add(linkKey);
                }
            }
        }
    }

    if (node.backlinks.length > 0) {
        for (const backlinkerId of node.backlinks) {
            const backlinkerHNode = allNodesMap.get(backlinkerId);
            if (
                backlinkerHNode &&
                !(!backlinkerHNode.isFolder && backlinkerHNode.data?.draft)
            ) {
                // Not a draft file
                const sourceGraphId = getEffectiveGraphId(backlinkerId);
                const targetGraphId = getEffectiveGraphId(node.id);

                if (sourceGraphId === targetGraphId) continue;

                let isHierarchicalAlready = false;
                if (
                    node.parent === backlinkerId ||
                    backlinkerHNode.parent === node.id
                ) {
                    const hierarchicalKey = [sourceGraphId, targetGraphId]
                        .sort()
                        .join("--");
                    if (
                        clientLinks.some(
                            (l) =>
                                !l.isBacklink &&
                                [l.source, l.target].sort().join("--") ===
                                    hierarchicalKey,
                        )
                    ) {
                        isHierarchicalAlready = true;
                    }
                }
                const isToSyntheticRoot =
                    sourceGraphId === SYNTHETIC_ROOT_ID ||
                    targetGraphId === SYNTHETIC_ROOT_ID;

                if (!isHierarchicalAlready && !isToSyntheticRoot) {
                    const linkKey = [sourceGraphId, targetGraphId]
                        .sort()
                        .join("--");
                    if (!linkSet.has(linkKey)) {
                        clientLinks.push({
                            source: sourceGraphId,
                            target: targetGraphId,
                            isBacklink: true,
                        });
                        linkSet.add(linkKey);
                    }
                }
            }
        }
    }
}

const hierarchicalData = { nodes: clientNodes, links: clientLinks };
---

<Layout>
    <Graph graphData={hierarchicalData} />
</Layout>
