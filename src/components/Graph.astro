---
import { compress, trimUndefinedRecursively } from "compress-json";

interface HierarchicalNodeFromProps {
    name: string;
    path: string;
    children?: HierarchicalNodeFromProps[];
    backlinks?: string[];
}

interface Props {
    data: HierarchicalNodeFromProps;
}

const { data: hierarchicalDataWithPaths } = Astro.props;

interface ClientTreeInputNode {
    name: string;
    children?: ClientTreeInputNode[];
    backlinks?: string[];
}

function transformTreeForClient(
    inputNode: HierarchicalNodeFromProps,
    parentName?: string,
): ClientTreeInputNode | null {
    if (parentName && inputNode.name === parentName) {
        return null;
    }

    let children: ClientTreeInputNode[] | undefined = undefined;
    if (inputNode.children) {
        children = inputNode.children
            .map((child) => transformTreeForClient(child, inputNode.name))
            .filter((child) => child !== null) as ClientTreeInputNode[];
        if (children.length === 0) {
            children = undefined;
        }
    }

    return {
        name: inputNode.name,
        backlinks: inputNode.backlinks,
        children: children,
    };
}

const rootHierarchicalNode = hierarchicalDataWithPaths;

let treeForClientSerializationReady: ClientTreeInputNode | null = 
    transformTreeForClient(rootHierarchicalNode);

if (!treeForClientSerializationReady) {
    console.error(
        "Root node was filtered out by transformTreeForClient. " + 
        "This likely means the top-level item of your data matched a folder note exclusion rule, which is unusual. " + 
        "Providing a minimal tree to avoid client errors."
    );
    return;
}

trimUndefinedRecursively(treeForClientSerializationReady);
const compressedTreeForClient = compress(treeForClientSerializationReady);
---

<style is:global>
    #force-graph-svg {
        & .node text {
            pointer-events: none;
            user-select: none;
            text-anchor: middle;
        }

        & .node,
        & .link {
            transition: opacity 0.3s ease-in-out;
        }

        & .node.fade,
        & .link.fade {
            opacity: 0.15;
        }

        & .node:not(.fade),
        & .link:not(.fade) {
            opacity: 1;
        }
    }
</style>

<div
    id="graph-container"
    class="m-auto h-150 max-w-3xl cursor-default overflow-hidden rounded-lg border-1 border-light-gray"
    data-client-tree={JSON.stringify(compressedTreeForClient)}
>
    <svg id="force-graph-svg" class="block h-full w-full"></svg>
</div>

<script>
    import { decompress } from "compress-json";
    import * as d3 from "d3";

    interface ClientTreeInputNode {
        name: string;
        children?: ClientTreeInputNode[];
        backlinks?: string[];
    }

    interface NodeDataForSim extends d3.SimulationNodeDatum {
        id: string;
        name: string;
        initialDepth: number;
        isLeaf: boolean;
        wasInitiallyFixed?: boolean;
    }

    interface InitialLinkData {
        source: string;
        target: string;
        isBacklink: boolean;
    }

    interface LinkDataForSim extends d3.SimulationLinkDatum<NodeDataForSim> {
        isBacklink: boolean;
    }

    function processTreeForD3(rootClientNode: ClientTreeInputNode) {
        const nodes: NodeDataForSim[] = [];
        const links: InitialLinkData[] = [];
        const fullAdjacencyMap = new Map<string, Set<string>>();
        const nodeMap = new Map<string, NodeDataForSim>();

        interface NodeWithOriginalBacklinks extends NodeDataForSim {
            originalBacklinks?: string[];
        }

        function traverseBuild(
            currentClientNode: ClientTreeInputNode,
            parentGeneratedPath: string,
            depth: number,
        ) {
            let nodeId: string;
            if (currentClientNode.name === "Content Root" && depth === 0) {
                nodeId = "/";
            } else if (parentGeneratedPath === "/") {
                nodeId = `/${currentClientNode.name}`;
            } else {
                nodeId = parentGeneratedPath
                    ? `${parentGeneratedPath}/${currentClientNode.name}`
                    : `/${currentClientNode.name}`;
                if (
                    depth === 0 &&
                    nodeId !== "/" &&
                    currentClientNode.name !== "Content Root"
                ) {
                    nodeId = `/${currentClientNode.name}`;
                }
            }

            if (!fullAdjacencyMap.has(nodeId)) {
                fullAdjacencyMap.set(nodeId, new Set());
            }

            let newNode: NodeWithOriginalBacklinks;
            if (!nodeMap.has(nodeId)) {
                newNode = {
                    id: nodeId,
                    name: currentClientNode.name,
                    initialDepth: depth,
                    isLeaf:
                        !currentClientNode.children ||
                        currentClientNode.children.length === 0,
                    fx: null,
                    fy: null,
                    originalBacklinks: currentClientNode.backlinks,
                };
                nodes.push(newNode);
                nodeMap.set(nodeId, newNode);
            } else {
                newNode = nodeMap.get(nodeId)! as NodeWithOriginalBacklinks;
                newNode.initialDepth = Math.min(newNode.initialDepth, depth);
                if (currentClientNode.backlinks) {
                    newNode.originalBacklinks = [
                        ...new Set([
                            ...(newNode.originalBacklinks || []),
                            ...currentClientNode.backlinks,
                        ]),
                    ];
                }
            }

            if (parentGeneratedPath && depth > 0) {
                links.push({
                    source: parentGeneratedPath,
                    target: nodeId,
                    isBacklink: false,
                });
                fullAdjacencyMap.get(parentGeneratedPath)!.add(nodeId);
                fullAdjacencyMap.get(nodeId)!.add(parentGeneratedPath);
            }

            if (currentClientNode.children) {
                currentClientNode.children.forEach((child) =>
                    traverseBuild(child, nodeId, depth + 1),
                );
            }
        }

        traverseBuild(rootClientNode, "", 0);

        nodes.forEach((node) => {
            const tempNode = node as NodeWithOriginalBacklinks;
            (tempNode.originalBacklinks || []).forEach((targetBacklinkPath) => {
                if (nodeMap.has(targetBacklinkPath)) {
                    if (!fullAdjacencyMap.get(node.id))
                        fullAdjacencyMap.set(node.id, new Set());
                    if (!fullAdjacencyMap.get(targetBacklinkPath))
                        fullAdjacencyMap.set(targetBacklinkPath, new Set());

                    fullAdjacencyMap.get(node.id)!.add(targetBacklinkPath);
                    fullAdjacencyMap.get(targetBacklinkPath)!.add(node.id);

                    const hierarchicalLinkExists = links.some(
                        (l) =>
                            !l.isBacklink &&
                            ((l.source === node.id &&
                                l.target === targetBacklinkPath) ||
                                (l.source === targetBacklinkPath &&
                                    l.target === node.id)),
                    );

                    if (!hierarchicalLinkExists) {
                        const backlinkAlreadyAdded = links.some(
                            (l) =>
                                l.isBacklink &&
                                ((l.source === node.id &&
                                    l.target === targetBacklinkPath) ||
                                    (l.source === targetBacklinkPath &&
                                        l.target === node.id)),
                        );
                        if (!backlinkAlreadyAdded) {
                            links.push({
                                source: node.id,
                                target: targetBacklinkPath,
                                isBacklink: true,
                            });
                        }
                    }
                } else {
                    console.warn(
                        `Backlink target path "${targetBacklinkPath}" not found for source "${node.id}".`,
                    );
                }
            });
            delete tempNode.originalBacklinks;
        });

        return { nodes, links, fullAdjacencyMap };
    }

    function runSimulation() {
        const BASE_RADIUS = 10;
        const VISUAL_RADIUS_SCALE_FACTOR = 0.8;
        const MIN_VISUAL_RADIUS = 3;
        const RADIAL_INCREMENT = 120;
        const RADIAL_STRENGTH = 0.9;
        const ROOT_NODE_ID = "/";
        const SIM_ALPHA_DECAY = 0.018;
        const SIM_CHARGE_STRENGTH = -1200;
        const DRAG_ALPHA_TARGET = 0.1;

        function calculateVisualNodeRadius(node: NodeDataForSim) {
            const depth = isFinite(node.initialDepth) ? node.initialDepth : 5;
            const depthFactor = Math.pow(VISUAL_RADIUS_SCALE_FACTOR, depth);
            return Math.max(MIN_VISUAL_RADIUS, BASE_RADIUS * depthFactor);
        }

        function getLinkKey(linkDatum: unknown) {
            const link = linkDatum as InitialLinkData;
            const sourceId = link.source;
            const targetId = link.target;
            return sourceId < targetId
                ? `${sourceId}-${targetId}`
                : `${targetId}-${sourceId}`;
        }

        const container = document.getElementById("graph-container");
        if (!container) {
            console.error("Graph container not found!");
            return;
        }
        const svg = d3.select<SVGSVGElement, unknown>("#force-graph-svg");

        const rawClientTreeData = container.dataset.clientTree;
        if (!rawClientTreeData) {
            console.error("Client tree data not found on container dataset!");
            return;
        }
        const clientTree: ClientTreeInputNode = decompress(
            JSON.parse(rawClientTreeData),
        );

        const {
            nodes,
            links: initialLinks,
            fullAdjacencyMap,
        } = processTreeForD3(clientTree);

        let width = container.clientWidth;
        let height = container.clientHeight;

        const rootNodeForInit = nodes.find((n) => n.id === ROOT_NODE_ID);
        if (rootNodeForInit) {
            rootNodeForInit.fx = width / 2;
            rootNodeForInit.fy = height / 2;
            rootNodeForInit.wasInitiallyFixed = true;
        }

        let simulation = d3
            .forceSimulation<NodeDataForSim, LinkDataForSim>(nodes)
            .force(
                "link",
                d3
                    .forceLink<NodeDataForSim, LinkDataForSim>(
                        initialLinks as any,
                    )
                    .id((d: NodeDataForSim) => d.id!)
                    .distance((d: LinkDataForSim) => {
                        return d.isBacklink ? 90 : 15;
                    })
                    .strength((d: LinkDataForSim) =>
                        d.isBacklink ? 0.1 : 0.9,
                    ),
            )
            .force("charge", d3.forceManyBody().strength(SIM_CHARGE_STRENGTH))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force(
                "collide",
                d3
                    .forceCollide<NodeDataForSim>()
                    .radius(
                        (d: NodeDataForSim) => calculateVisualNodeRadius(d) + 4,
                    )
                    .iterations(2),
            )
            .force(
                "radial",
                d3
                    // @ts-ignore
                    .forceRadial<NodeDataForSim>()
                    .radius((d: NodeDataForSim) =>
                        isFinite(d.initialDepth)
                            ? d.initialDepth * RADIAL_INCREMENT
                            : Math.max(width, height) * 1.5,
                    )
                    .strength((d: NodeDataForSim) =>
                        isFinite(d.initialDepth) ? RADIAL_STRENGTH : 0.05,
                    )
                    .x(width / 2)
                    .y(height / 2),
            )
            .alphaDecay(SIM_ALPHA_DECAY)
            .alphaTarget(0);

        const linkGroup = svg.append("g").attr("class", "links");
        const nodeGroup = svg.append("g").attr("class", "nodes");

        const zoomBehavior = d3
            .zoom<SVGSVGElement, unknown>()
            .scaleExtent([0.1, 8])
            .on("zoom", (event: d3.D3ZoomEvent<SVGSVGElement, unknown>) => {
                linkGroup.attr("transform", event.transform.toString());
                nodeGroup.attr("transform", event.transform.toString());
            });
        svg.call(zoomBehavior);

        let linkElements = linkGroup
            .selectAll("line.link")
            .data<InitialLinkData>(initialLinks, getLinkKey)
            .join("line")
            .attr(
                "class",
                (d: InitialLinkData) =>
                    `link ${d.isBacklink ? "stroke-gray stroke-1 [stroke-dasharray:3,3]" : "stroke-gray stroke-2"}`,
            );

        let nodeElements = nodeGroup
            .selectAll<SVGGElement, NodeDataForSim>("g.node")
            .data<NodeDataForSim>(nodes, (d: NodeDataForSim) => d.id!)
            .join<SVGGElement>("g")
            .attr("class", "node");

        nodeElements
            .append("circle")
            .attr("r", (d: NodeDataForSim) => calculateVisualNodeRadius(d))
            .attr(
                "class",
                (d: NodeDataForSim) =>
                    `stroke-dark-gray stroke-1 cursor-pointer ${d.isLeaf ? "fill-primary" : "fill-secondary"}`,
            );

        nodeElements
            .append("text")
            .attr("dy", "0.35em")
            .attr("y", (d: NodeDataForSim) => calculateVisualNodeRadius(d) + 7)
            .attr("class", "text-xs fill-dark")
            .text((d: NodeDataForSim) => d.name);

        const ticked = () => {
            linkElements
                .attr(
                    "x1",
                    (d: LinkDataForSim) => (d.source as NodeDataForSim).x ?? 0,
                )
                .attr(
                    "y1",
                    (d: LinkDataForSim) => (d.source as NodeDataForSim).y ?? 0,
                )
                .attr(
                    "x2",
                    (d: LinkDataForSim) => (d.target as NodeDataForSim).x ?? 0,
                )
                .attr(
                    "y2",
                    (d: LinkDataForSim) => (d.target as NodeDataForSim).y ?? 0,
                );

            nodeElements.attr(
                "transform",
                (d: NodeDataForSim) => `translate(${d.x ?? 0},${d.y ?? 0})`,
            );
        };
        simulation.on("tick", ticked);

        const dragBehavior = d3
            .drag<SVGGElement, NodeDataForSim>()
            .on(
                "start",
                function (
                    this: SVGGElement,
                    event: d3.D3DragEvent<
                        SVGGElement,
                        NodeDataForSim,
                        NodeDataForSim
                    >,
                    d: NodeDataForSim,
                ) {
                    if (!event.active)
                        simulation.alphaTarget(DRAG_ALPHA_TARGET).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                    d3.select(this)
                        .classed("cursor-grabbing", true)
                        .classed("cursor-pointer", false);
                },
            )
            .on(
                "drag",
                (
                    event: d3.D3DragEvent<
                        SVGGElement,
                        NodeDataForSim,
                        NodeDataForSim
                    >,
                    d: NodeDataForSim,
                ) => {
                    d.fx = event.x;
                    d.fy = event.y;
                },
            )
            .on(
                "end",
                function (
                    this: SVGGElement,
                    event: d3.D3DragEvent<
                        SVGGElement,
                        NodeDataForSim,
                        NodeDataForSim
                    >,
                    d: NodeDataForSim,
                ) {
                    if (!event.active) simulation.alphaTarget(0);

                    if (!d.wasInitiallyFixed) {
                        d.fx = null;
                        d.fy = null;
                    }
                    d3.select(this)
                        .classed("cursor-grabbing", false)
                        .classed("cursor-pointer", true);
                },
            );
        nodeElements.call(dragBehavior);

        nodeElements
            .on(
                "mouseover",
                function (
                    this: SVGGElement,
                    event: MouseEvent,
                    d: NodeDataForSim,
                ) {
                    const hoveredNodeId = d.id!;

                    const neighbors = new Set<string>(
                        fullAdjacencyMap.get(hoveredNodeId) || [],
                    );
                    neighbors.add(hoveredNodeId);

                    nodeElements.classed(
                        "fade",
                        (n: NodeDataForSim) => !neighbors.has(n.id!),
                    );

                    d3.select(this).select("circle").classed("highlight", true);
                    d3.select(this).classed("fade", false);

                    linkElements.classed("fade", (l: LinkDataForSim) => {
                        const sourceId = (l.source as NodeDataForSim).id;
                        const targetId = (l.target as NodeDataForSim).id;
                        return (
                            sourceId !== hoveredNodeId &&
                            targetId !== hoveredNodeId
                        );
                    });
                },
            )
            .on(
                "mouseout",
                function (
                    this: SVGGElement,
                    event: MouseEvent,
                    d: NodeDataForSim,
                ) {
                    nodeElements.classed("fade", false);
                    d3.select(this)
                        .select("circle")
                        .classed("highlight", false);
                    linkElements.classed("fade", false);
                },
            );

        const resizeObserver = new ResizeObserver((entries) => {
            if (!entries || entries.length === 0) return;
            const entry = entries[0];
            const newWidth = entry.contentRect.width;
            const newHeight = entry.contentRect.height;

            if (width !== newWidth || height !== newHeight) {
                width = newWidth;
                height = newHeight;

                svg.attr("width", width).attr("height", height);

                simulation.force(
                    "center",
                    d3.forceCenter(width / 2, height / 2),
                );
                const radialForce =
                    simulation.force<d3.ForceRadial<NodeDataForSim>>("radial");
                if (radialForce) {
                    radialForce
                        .x(width / 2)
                        .y(height / 2)
                        .radius((node: NodeDataForSim) =>
                            isFinite(node.initialDepth)
                                ? node.initialDepth * RADIAL_INCREMENT
                                : Math.max(width, height) * 1.5,
                        );
                }

                const root = nodes.find((n) => n.id === ROOT_NODE_ID);
                if (root) {
                    root.fx = width / 2;
                    root.fy = height / 2;
                }

                simulation.alpha(0.4).restart();

                setTimeout(() => {
                    if (root && !root.wasInitiallyFixed) {
                        root.fx = null;
                        root.fy = null;
                    }
                    simulation.alphaTarget(0);
                }, 1500);
            }
        });
        resizeObserver.observe(container);

        simulation.alpha(1).restart();
        setTimeout(() => {
            const rootNode = nodes.find((n) => n.id === ROOT_NODE_ID);
            if (rootNode && rootNode.wasInitiallyFixed) {
                rootNode.fx = null;
                rootNode.fy = null;
                rootNode.wasInitiallyFixed = false;
            }
            simulation.alphaTarget(0);
        }, 2000);

        ticked();
    }

    runSimulation();
</script>
