---
import { compress } from "compress-json";

interface ClientGraphNode {
    id: string;
    isFolder: boolean;
    initialDepth: number;
}

interface ClientGraphLink {
    source: string;
    target: string;
    isBacklink: boolean;
}

interface Props {
    graphData: {
        nodes: ClientGraphNode[];
        links: ClientGraphLink[];
    };
}

const { graphData } = Astro.props;
const compressedGraphData = compress(graphData);
---

<style is:global>
    #force-graph-svg {
        & .node text {
            pointer-events: none;
            user-select: none;
            text-anchor: middle;
        }

        & .node,
        & .link {
            transition: opacity 0.3s ease-in-out;
        }

        & .node.fade,
        & .link.fade {
            opacity: 0.15;
        }

        & .node:not(.fade),
        & .link:not(.fade) {
            opacity: 1;
        }
    }
</style>

<div
    id="graph-container"
    class="m-auto h-[calc(100vh-9rem)] max-w-3xl cursor-default overflow-hidden rounded-lg border-1 border-light-gray"
    data-graph-data={JSON.stringify(compressedGraphData)}
>
    <svg id="force-graph-svg" class="block h-full w-full"></svg>
</div>

<script>
    import { decompress } from "compress-json";
    import * as d3 from "d3";

    interface ClientGraphNode {
        id: string;
        isFolder: boolean;
        initialDepth: number;
    }

    interface ClientGraphLink {
        source: string;
        target: string;
        isBacklink: boolean;
    }

    interface GraphData {
        nodes: ClientGraphNode[];
        links: ClientGraphLink[];
    }

    interface NodeDataForSim extends d3.SimulationNodeDatum, ClientGraphNode {
        wasInitiallyFixed?: boolean;
    }

    interface LinkDataForSim
        extends d3.SimulationLinkDatum<NodeDataForSim>,
            Omit<ClientGraphLink, "source" | "target"> {}

    function runSimulation() {
        const BASE_RADIUS = 10;
        const VISUAL_RADIUS_SCALE_FACTOR = 0.8;
        const MIN_VISUAL_RADIUS = 3;
        const RADIAL_INCREMENT = 120;
        const RADIAL_STRENGTH = 0.9;
        const SIM_ALPHA_DECAY = 0.018;
        const SIM_CHARGE_STRENGTH = -1200;
        const DRAG_ALPHA_TARGET = 0.1;

        function calculateVisualNodeRadius(node: NodeDataForSim) {
            const depth = isFinite(node.initialDepth) ? node.initialDepth : 5;
            const depthFactor = Math.pow(VISUAL_RADIUS_SCALE_FACTOR, depth);
            return Math.max(MIN_VISUAL_RADIUS, BASE_RADIUS * depthFactor);
        }

        function getLinkKey(linkDatum: unknown) {
            const link = linkDatum as ClientGraphLink;
            const sourceId = link.source;
            const targetId = link.target;
            return sourceId < targetId
                ? `${sourceId}-${targetId}`
                : `${targetId}-${sourceId}`;
        }

        const container = document.getElementById("graph-container");
        if (!container) {
            console.error("Graph container not found!");
            return;
        }
        const svg = d3.select<SVGSVGElement, unknown>("#force-graph-svg");

        const rawGraphData = container.dataset.graphData;
        if (!rawGraphData) {
            console.error("Graph data not found on container dataset!");
            return;
        }
        const decompressedGraphData: GraphData = decompress(
            JSON.parse(rawGraphData),
        );

        const d3Nodes: NodeDataForSim[] = decompressedGraphData.nodes.map(
            (n) => ({ ...n }),
        );
        const d3Links: ClientGraphLink[] = decompressedGraphData.links.map(
            (l) => ({ ...l }),
        );

        const fullAdjacencyMap = new Map<string, Set<string>>();
        d3Nodes.forEach((node) =>
            fullAdjacencyMap.set(node.id, new Set<string>()),
        );
        d3Links.forEach((link) => {
            fullAdjacencyMap.get(link.source)?.add(link.target);
            fullAdjacencyMap.get(link.target)?.add(link.source);
        });

        let width = container.clientWidth;
        let height = container.clientHeight;

        const firstRootNode = d3Nodes.find((n) => n.initialDepth === 0);
        if (firstRootNode) {
            firstRootNode.fx = width / 2;
            firstRootNode.fy = height / 2;
            firstRootNode.wasInitiallyFixed = true;
        }

        const linkForce = d3.forceLink<NodeDataForSim, LinkDataForSim>(d3Links);
        linkForce.id((d: NodeDataForSim) => d.id);
        linkForce.distance((d: LinkDataForSim) => (d.isBacklink ? 90 : 40));
        linkForce.strength((d: LinkDataForSim) => (d.isBacklink ? 0.1 : 0.9));

        let simulation = d3
            .forceSimulation<NodeDataForSim, LinkDataForSim>(d3Nodes)
            .force("link", linkForce)
            .force("charge", d3.forceManyBody().strength(SIM_CHARGE_STRENGTH))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force(
                "collide",
                d3
                    .forceCollide<NodeDataForSim>()
                    .radius(
                        (d: NodeDataForSim) => calculateVisualNodeRadius(d) + 4,
                    )
                    .iterations(2),
            )
            .force(
                "radial",
                d3
                    // @ts-ignore
                    .forceRadial<NodeDataForSim>()
                    .radius((d: NodeDataForSim) =>
                        isFinite(d.initialDepth)
                            ? d.initialDepth * RADIAL_INCREMENT
                            : Math.max(width, height) * 1.5,
                    )
                    .strength((d: NodeDataForSim) =>
                        isFinite(d.initialDepth) ? RADIAL_STRENGTH : 0.05,
                    )
                    .x(width / 2)
                    .y(height / 2),
            )
            .alphaDecay(SIM_ALPHA_DECAY)
            .alphaTarget(0);

        const linkGroup = svg.append("g").attr("class", "links");
        const nodeGroup = svg.append("g").attr("class", "nodes");

        const zoomBehavior = d3
            .zoom<SVGSVGElement, unknown>()
            .scaleExtent([0.1, 8])
            .on("zoom", (event: d3.D3ZoomEvent<SVGSVGElement, unknown>) => {
                linkGroup.attr("transform", event.transform.toString());
                nodeGroup.attr("transform", event.transform.toString());
            });
        svg.call(zoomBehavior);

        let linkElements = linkGroup
            .selectAll("line.link")
            .data<ClientGraphLink>(d3Links, getLinkKey)
            .join("line")
            .attr(
                "class",
                (d: ClientGraphLink) =>
                    `link stroke-gray ${d.isBacklink ? "stroke-1 [stroke-dasharray:3,3]" : "stroke-2"}`,
            );

        let nodeElements = nodeGroup
            .selectAll<SVGGElement, NodeDataForSim>("g.node")
            .data<NodeDataForSim>(d3Nodes, (d: NodeDataForSim) => d.id)
            .join<SVGGElement>("g")
            .attr("class", "node");

        nodeElements
            .append("circle")
            .attr("r", (d: NodeDataForSim) => calculateVisualNodeRadius(d))
            .attr("class", "cursor-pointer")
            .attr(
                "style",
                (d) =>
                    `fill: color-mix(in oklch, var(--color-secondary), var(--color-primary) ${(100 / (d.initialDepth + 1) ** 0.6).toFixed(2)}%)`,
            );

        nodeElements
            .append("text")
            .attr("dy", "0.35em")
            .attr("y", (d: NodeDataForSim) => calculateVisualNodeRadius(d) + 7)
            .attr("class", "text-xs fill-dark")
            .text((d: NodeDataForSim) => {
                const name = d.id.split("/").pop() ?? "";
                if (name === "") {
                    return "Home";
                } else {
                    return name;
                }
            });

        const ticked = () => {
            linkElements
                .attr(
                    "x1",
                    (d: LinkDataForSim) => (d.source as NodeDataForSim).x ?? 0,
                )
                .attr(
                    "y1",
                    (d: LinkDataForSim) => (d.source as NodeDataForSim).y ?? 0,
                )
                .attr(
                    "x2",
                    (d: LinkDataForSim) => (d.target as NodeDataForSim).x ?? 0,
                )
                .attr(
                    "y2",
                    (d: LinkDataForSim) => (d.target as NodeDataForSim).y ?? 0,
                );

            nodeElements.attr(
                "transform",
                (d: NodeDataForSim) => `translate(${d.x ?? 0},${d.y ?? 0})`,
            );
        };
        simulation.on("tick", ticked);

        const dragBehavior = d3
            .drag<SVGGElement, NodeDataForSim>()
            .on(
                "start",
                function (
                    this: SVGGElement,
                    event: d3.D3DragEvent<
                        SVGGElement,
                        NodeDataForSim,
                        NodeDataForSim
                    >,
                    d: NodeDataForSim,
                ) {
                    if (!event.active)
                        simulation.alphaTarget(DRAG_ALPHA_TARGET).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                    d3.select(this)
                        .classed("cursor-grabbing", true)
                        .classed("cursor-pointer", false);
                },
            )
            .on(
                "drag",
                (
                    event: d3.D3DragEvent<
                        SVGGElement,
                        NodeDataForSim,
                        NodeDataForSim
                    >,
                    d: NodeDataForSim,
                ) => {
                    d.fx = event.x;
                    d.fy = event.y;
                },
            )
            .on(
                "end",
                function (
                    this: SVGGElement,
                    event: d3.D3DragEvent<
                        SVGGElement,
                        NodeDataForSim,
                        NodeDataForSim
                    >,
                    d: NodeDataForSim,
                ) {
                    if (!event.active) simulation.alphaTarget(0);

                    if (!d.wasInitiallyFixed) {
                        d.fx = null;
                        d.fy = null;
                    }
                    d3.select(this)
                        .classed("cursor-grabbing", false)
                        .classed("cursor-pointer", true);
                },
            );
        nodeElements.call(dragBehavior);

        nodeElements
            .on("click", (event: MouseEvent, d: NodeDataForSim) => {
                if (event.defaultPrevented) return;
                const postPath = d.id;
                if (postPath === "/") {
                    window.location.href = "/";
                }
                window.location.href = `/posts${postPath}/`;
            })
            .on(
                "mouseover",
                function (
                    this: SVGGElement,
                    event: MouseEvent,
                    d: NodeDataForSim,
                ) {
                    const hoveredNodeId = d.id;

                    const neighbors = new Set<string>(
                        fullAdjacencyMap.get(hoveredNodeId) || [],
                    );
                    neighbors.add(hoveredNodeId);

                    nodeElements.classed(
                        "fade",
                        (n: NodeDataForSim) => !neighbors.has(n.id),
                    );

                    d3.select(this).select("circle").classed("highlight", true);
                    d3.select(this).classed("fade", false);

                    linkElements.classed("fade", (l: LinkDataForSim) => {
                        const sourceId = (l.source as NodeDataForSim).id;
                        const targetId = (l.target as NodeDataForSim).id;
                        return (
                            sourceId !== hoveredNodeId &&
                            targetId !== hoveredNodeId
                        );
                    });
                },
            )
            .on(
                "mouseout",
                function (
                    this: SVGGElement,
                    event: MouseEvent,
                    d: NodeDataForSim,
                ) {
                    nodeElements.classed("fade", false);
                    d3.select(this)
                        .select("circle")
                        .classed("highlight", false);
                    linkElements.classed("fade", false);
                },
            );

        const resizeObserver = new ResizeObserver((entries) => {
            if (!entries || entries.length === 0) return;
            const entry = entries[0];
            const newWidth = entry.contentRect.width;
            const newHeight = entry.contentRect.height;

            if (width !== newWidth || height !== newHeight) {
                width = newWidth;
                height = newHeight;

                svg.attr("width", width).attr("height", height);

                simulation.force(
                    "center",
                    d3.forceCenter(width / 2, height / 2),
                );
                const radialForce =
                    simulation.force<d3.ForceRadial<NodeDataForSim>>("radial");
                if (radialForce) {
                    radialForce
                        .x(width / 2)
                        .y(height / 2)
                        .radius((node: NodeDataForSim) =>
                            isFinite(node.initialDepth)
                                ? node.initialDepth * RADIAL_INCREMENT
                                : Math.max(width, height) * 1.5,
                        );
                }

                const currentFirstRootNode = d3Nodes.find(
                    (n) => n.initialDepth === 0,
                );
                if (currentFirstRootNode) {
                    currentFirstRootNode.fx = width / 2;
                    currentFirstRootNode.fy = height / 2;
                }

                simulation.alpha(0.4).restart();

                setTimeout(() => {
                    if (
                        currentFirstRootNode &&
                        !currentFirstRootNode.wasInitiallyFixed
                    ) {
                        currentFirstRootNode.fx = null;
                        currentFirstRootNode.fy = null;
                    } else if (
                        currentFirstRootNode &&
                        currentFirstRootNode.wasInitiallyFixed
                    ) {
                        // For now, let's assume it can be released if we re-fix on every resize
                    }
                    simulation.alphaTarget(0);
                }, 1500);
            }
        });
        resizeObserver.observe(container);

        simulation.alpha(1).restart();
        setTimeout(() => {
            const currentFirstRootNode = d3Nodes.find(
                (n) => n.initialDepth === 0 && n.wasInitiallyFixed,
            );
            if (currentFirstRootNode) {
                currentFirstRootNode.fx = null;
                currentFirstRootNode.fy = null;
                currentFirstRootNode.wasInitiallyFixed = false;
            }
            simulation.alphaTarget(0);
        }, 2000);

        ticked();
    }

    runSimulation();
</script>
